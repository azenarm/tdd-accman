# پرسش اول

همانطور که گفته شده برای سادگی آزمایش لازم نیست در لیست تراکنش ها منفی نشدن را در هر لحظه بررسی کنیم اما در نهایت نباید به ازای یک لیست تراکنش موجودی حساب منفی شود. این در حالی است که در سناریو هایی که برای تست در نظر گرفته شده، در هیچ موردی برداشت بیشتر از واریز نبوده و لذا این حالت بررسی نمیشده. از آنجایی که کلیت عملکرد برنامه درست است و حتی یک تست شامل هر دوی واریز و برداشت نوشته شده، احتمالا حواس برنامه نویس از وجود این خطا پرت شده است.

# پرسش دوم

ابتدا تستی به نام

testCalculateBalanceThrowsErrorWhenNegative

اضافه کردیم که در صورت منفی شدن موجودی خطایی را برگرداند. طبیعتا قبل از اعمال تغییر در کد این تست به این صورت فیل میشد:

edu.sharif.selab.AccountBalanceCalculatorTest.testCalculateBalanceThrowsErrorWhenNegative -- Time elapsed: 0.007 s <<< FAILURE!
org.opentest4j.AssertionFailedError: Balance cannot be negative ==> Expected java.lang.IllegalArgumentException to be thrown, but nothing was thrown.

سپس با اعمال تغییر در متد مربوطه، این تست نیز با موفقیت پاس شد.

Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.051 s -- in edu.sharif.selab.AccountBalanceCalculatorTest

# پرسش سوم

ممکن است به راحتی نوشتن تست برای حالات لبه ای را فراموش کنیم. چون حجم زیادی از کد را نوشتیم و احتمال میدهیم نوشتن تعدادی تست کل حالات را پوشش دهد و نمیتوانیم کنترل دقیقی روی پوشش کامل سناریو های مختلف داشته باشیم. در صورتی که اگر نیازمندی ها را تبدیل به تست های فیل شونده کنیم و سپس برای هر کدام کد مناسب بنویسیم، احتمال از دست دادن یک سناریوی خاص خیلی کمتر میشود.

# پرسش چهارم
در این حالت برخلاف حالت قبل، تست‌ها بدون سو گیری به نحوه پیاده‌سازی نوشته شده‌اند و اطمینان بیشتری از برآورده شدن نیازمندی‌های مسئله وجود دارد. همچنین با توجه به اینکه تست‌ها قبل از خود کد نوشته شده‌اند، هنگام نوشتن کد و ریفکتور کردن اطمینان بیشتری از صحت برنامه وجود دارد.

# پرسش پنچم
از مزایای روش مبتنی بر آزمون می‌توان به طراحی بهتر نرم‌افزار اشاره کرد. در این روش طراحی نرم‌افزار باید به گونه‌ای باشد که بتوان آن را به سادگی تست کرد و همین باعث می‌شود ساختار برنامه به صورت ماژولار و مستقل طراحی شود.
همچنین خود تست‌های نوشته شده به نوعی مستندات برنامه محسوب می‌شوند و با خواندن آن‌ها می‌توان رفتار مورد انتظار برنامه را بدون نیاز به مستند خارجی، متوجه شد.
علاوه بر این، با توجه به اینکه تست‌ها قبل از کد نوشته می‌شوند، اطمینان به برنامه افزایش پیدا می‌کند و باگ‌های برنامه کمتر می‌شوند. این باعث می‌شود که بتوان توسعه‌ای پایدار داشت و با هر تغییر مطمئن بود که برنامه همچنان عملکرد درستی دارد.

البته توسعه مبتنی بر تست معایبی هم دارد. اولین عیب آن این هست که در ابتدای شروع به توسعه مبتنی بر تست، سرعت توسعه بسیار شاید کند خواهد بود و برای افزایش سرعت توسعه نیاز به زمان و تجربه دارد. علاوه بر این برای توسعه مبتنی بر تست، باید به صورت دقیق interfaceهای برنامه مشخص باشند. در صورتی که ممکن است دقیق کردن آن‌ها در ابتدای توسعه کاری سخت باشد. حتی در شرایطی که هنوز نیازمندی‌ها هنوز دقیق مشخص نشده باشند شاید این کار ممکن به نظر نرسد. از طرفی برای برخی پروژه‌های کوچک ممکن است استفاده از روش مبتنی بر تست نیازی نباشد و فرایند توسعه نرم‌افزار را کند کند. 